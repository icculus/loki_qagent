#include "host_def.h"
#include "qagent_globals.h"
#include "utils.h"

#include <pwd.h>
#include <sys/param.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <sys/vfs.h>
#include <limits.h>
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>

void parse_args( int argc, char *argv [])
{
	product_name = NULL;
	product_version = NULL;
	product_cdrom = NULL;
	product_desc = NULL;
	product_prefs = NULL;
	product_path = NULL;

	argv0 =  (char *)malloc(strlen(argv[0])+1);
	strcpy(argv0,argv[0]);

	for (int i = 1; i < argc; i++)
	{
		if (strcasecmp(argv[i],"--product_name") == 0)
		{
			i++;
			printf("product_name: %s\n",argv[i]);
			product_name = (char *)malloc(strlen(argv[i])+1);
			strcpy(product_name,argv[i]);
		}

		else if (strcasecmp(argv[i],"--product_version") == 0)
		{
			i++;
			printf("product_version: %s\n",argv[i]);
			product_version = (char *)malloc(strlen(argv[i])+1);
			strcpy(product_version,argv[i]);
		}

		else if (strcasecmp(argv[i],"--product_path") == 0)
		{
			i++;
			printf("product_path: %s\n",argv[i]);
			product_path = (char *)malloc(strlen(argv[i])+1);
			strcpy(product_path,argv[i]);
		}

		else if (strcasecmp(argv[i],"--product_desc") == 0)
		{
			i++;
			printf("product_desc: %s\n",argv[i]);

// we need to make sure that we add other exciting stuff.

			product_desc = (char *)malloc(strlen(argv[i])+1);
			strcpy(product_desc,argv[i]);

		}

		else if (strcasecmp(argv[i],"--product_cdrom") == 0)
		{
			i++;
			printf("product_cdrom: %s\n",argv[i]);
			if (strlen(argv[i]) > 0)
			{
				product_cdrom = (char *)malloc(strlen(argv[i])+1);
				strcpy(product_cdrom,argv[i]);
			}
		}

		else if (strcasecmp(argv[i],"--product_prefs") == 0)
		{
			i++;
			printf("product_prefs: %s\n",argv[i]);
			product_prefs = (char *)malloc(strlen(argv[i])+1);
			strcpy(product_prefs,argv[i]);
		}

		else if (strcasecmp(argv[i],"--stack_trace") == 0)
		{
			i++;
			printf("stack_trace: %s\n",argv[i]);
			stack_trace_path = (char *)malloc(strlen(argv[i])+1);
			strcpy(stack_trace_path,argv[i]);
		}

		else
		{
//todo: print usage dialog
			printf("Unknown parameter %s\n",argv[i]);
			exit(2);
		}
	
	}
}

void prepare_for_launch ( void )
{
	home = NULL;
	work_dir = NULL;

	home = getenv("HOME");

	if (home == NULL)
	{
		uid_t id = getuid();
		struct passwd *pwd;
	
		setpwent();

		while ((pwd = getpwent()) != NULL)
		{
			if (pwd->pw_uid == id)
			{
				home = pwd->pw_dir;
				break;
			}
		}
		endpwent();
	}

	printf("home: %s\n",home);
	support_path = (char *)malloc(strlen(home)+strlen(_GEN_HOSTDEF_SUPPORT_DIRECTORY)+1);
	strcpy(support_path,home);
	strcat(support_path,_GEN_HOSTDEF_SUPPORT_DIRECTORY);
#ifdef VERBOSE
	printf("support_path: %s\n",support_path);
#endif
	dump_path = (char *)malloc(strlen(support_path)+strlen(DUMP_FILE)+1);
	strcpy(dump_path,support_path);
	strcat(dump_path,DUMP_FILE);
#ifdef VERBOSE
	printf("dump_path: %s\n",dump_path);
#endif
	
// This next bit of code is mainly from the Loki utility code. -- n.

	char temp_path[PATH_MAX], env[100], data_path[PATH_MAX];
	
	strcpy(temp_path, argv0);
	if (!strrchr(temp_path,'/'))
	{
		char *path;
		char *last;
		int found;

		found = 0;
		path = getenv("PATH");
		do
		{
			temp_path[0] = '\0';
			last = strchr(path, ':');
			if (*path == '~') 
			{
				strcpy(temp_path, home);
				++path;
			}
			
			if ( last > (path + 1) )
			{
				strncat ( temp_path, path, (last-path));
				strcat (temp_path, "/");
			}
			
			strcat(temp_path, "./");
			strcat(temp_path, argv0);
			
			if (access(temp_path, X_OK) == 0)
			{
				++found;
			}

			path = last + 1;
		} while ( *last && !found );

	}

	else

	{
		argv0 = strrchr(argv0, '/')+1;
	}

	if (realpath(temp_path, data_path) )
	{
		*(strrchr(data_path, '/')) = '\0';
	}

	work_dir = (char *)malloc(strlen(data_path)+1);
	strcpy(work_dir, data_path);

	printf("work_dir: %s\n",work_dir);		
}

void gen_header ( void )
{

	header_path = (char *)malloc(strlen(support_path)+strlen(HEADER_FILE)+1);
	strcpy(header_path,support_path);
	strcat(header_path,HEADER_FILE);
	printf("header_path: %s\n",header_path);
	
	FILE *fp = fopen(header_path,"wt");

	if (fp == NULL)
	{
		printf("Couldn't generate header file\n");

// I haven't decided how we want to handle this. At some point implementing
// a try/catch system for error handling would be appropriate. -- n.

		return;
	}
	
	fprintf(fp,"This file was automatically generated by %s (%s)\n",_GEN_HOSTDEF_PROGRAM_NAME,QAGENT_VERSION);
	fprintf(fp,"\n");
	if (product_name == NULL)
	{
		fprintf(fp,"QAgent did not receive product information.\n");
	}
	else
	{
		fprintf(fp,"Product Name: %s\n",product_name);
		fprintf(fp,"Product Version: %s\n",product_version);
		fprintf(fp,"Product Description: %s\n",product_desc);
		fprintf(fp,"\n");
		fprintf(fp,"Product Path: %s\n", product_path);
		fprintf(fp,"\n");
	}

	fprintf(fp,"\n");
	fprintf(fp,"User's name: %s\n",user_name);
	fprintf(fp,"User's e-mail address: %s\n",user_email);

	if (user_regno == NULL)
	{
		fprintf(fp,"User did not submit a registration number\n");
	}
	else
	{
		fprintf(fp,"User's registration number: %s\n", user_regno);
	}
	fprintf(fp,"\n");
	if (user_comment == NULL)
	{
		fprintf(fp,"User did not leave a comment\n");
	}
	else
	{
		fprintf(fp,"User comment: \n");
		fprintf(fp,"------------------------\n");
		fprintf(fp,"%s\n",user_comment);
		fprintf(fp,"------------------------\n");
	}
	fprintf(fp,"\n");

	fclose(fp);	
}

int check_for_GPG ( void )
{
	FILE *fp = fopen("/usr/local/bin/gpg", "rb");
	if (fp)
	{
		fclose(fp);
		return TRUE;
	}
	fp = fopen("/usr/bin/gpg", "rb");
	if (fp)
	{
		fclose(fp);
		return TRUE;
	}
	
	useGPG = FALSE;	// if we don't have it, we don't use it. :)

	return FALSE;
	
}
